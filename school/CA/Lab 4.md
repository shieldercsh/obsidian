# 1. Adding pipelining registers

이번 과제의 1번 문항은 단일 사이클 CPU를 5단계 파이프라인 구조로 재구성하기 위해 단계 사이에 파이프라인 레지스터를 추가하고, 단계별 조합 논리 경로를 분리하여 연결하는 작업이다. 과제 요구에 따라 IF 단계 구현은 주어진 구조를 유지하고, ID EX MEM WB 단계를 완성하는 방향으로 구현을 진행하였다. 파이프라인 레지스터와 제어 신호는 Bundle로 정의하여 각 단계 경계에서 레지스터에 래치되도록 구성하였고, 스켈레톤에 남아 있던 DontCare는 실제 연결이 끝난 이후 의미 있는 값으로 구동되도록 제거하였다.
구현의 핵심은 데이터 경로와 제어 경로를 함께 파이프라인 레지스터에 실어 나르는 구조를 만드는 일이다. IF ID 레지스터에는 fetch된 instruction과 PC, PC+4를 저장하여 다음 사이클의 ID 단계가 안정적으로 디코드할 수 있게 하였다. ID 단계에서는 opcode를 기반으로 Control Unit이 생성한 제어 신호를 단계별로 분리하여 EXControl MControl WBControl로 묶고 이를 ID EX 레지스터에 저장하였다. 또한 레지스터 파일에서 읽어온 readdata1 readdata2, 목적지 레지스터 rd, 즉시값 imm, 그리고 분기 및 메모리 접근에 필요한 funct3 funct7도 ID EX로 전달하였다. 이 구성은 상승 에지에서 각 단계의 입력 상태를 고정하고 다음 사이클에 레지스터 출력만으로 다음 단계 조합 논리가 계산되는 전형적인 파이프라인 동작을 보장한다.
EX 단계에서는 ID EX에 저장된 제어 신호와 피연산자를 바탕으로 ALUControl을 통해 연산 종류를 결정하고, ALU 입력 선택을 위한 MUX를 구성하여 alusrc1 및 immediate 제어에 따라 입력을 선택하도록 하였다. 예를 들어 x 입력은 rs1 0 PC 중에서 선택되고 y 입력은 rs2 imm 중에서 선택된다. 계산된 ALU 결과와 store를 위한 writedata, 그리고 이후 단계에서 필요한 memread memwrite toreg regwrite 신호는 EX MEM 레지스터에 저장하여 MEM 단계에서 데이터 메모리 인터페이스에 직접 연결하였다. MEM 단계에서 얻은 readdata와 ALU 결과, PC+4, rd 및 WB 제어 신호는 MEM WB 레지스터에 저장하고, WB 단계에서는 toreg 값에 따라 ALU 결과 메모리 읽기 값 PC+4 중 하나를 선택해 레지스터 파일에 write back을 수행하도록 구성하였다. 또한 x0 레지스터 불변성을 보장하기 위해 rd가 0인 경우에는 write enable이 발생하지 않도록 조건을 추가하여 안정적인 동작을 확보하였다.

# 2. Forwarding logic

2번 문항에서는 데이터 해저드로 인해 EX 단계에서 필요한 피연산자가 아직 레지스터 파일에 기록되지 않은 상황을 해결하기 위해 포워딩 로직을 구현하였다. 포워딩의 목적은 파이프라인을 불필요하게 멈추지 않고도 최근에 계산된 결과를 바로 사용하게 하는 데 있으며, 이를 위해 MEM 단계와 WB 단계의 결과를 EX 단계로 우회 전달하는 경로를 추가하였다. 구현은 ForwardingUnit을 통해 의존 관계를 판별하고, 그 결과에 따라 EX 단계의 입력 선택 MUX가 적절한 값을 선택하도록 구성하였다.
ForwardingUnit은 EX 단계에서 사용되는 소스 레지스터 번호 rs1 rs2와, MEM 단계 및 WB 단계에 존재하는 명령의 목적지 레지스터 번호 exmemrd memwbrd 및 레지스터 파일 쓰기 여부 exmemrw memwbrw를 입력으로 받는다. 이후 rs1 rs2가 각각 exmemrd 또는 memwbrd와 일치하면서 해당 단계의 명령이 레지스터 파일에 값을 쓸 예정이면 포워딩이 필요하다고 판단한다. 이때 동일한 레지스터에 대해 MEM 단계와 WB 단계 모두가 후보가 될 수 있으므로, 가장 최신 값이 존재하는 MEM 단계 포워딩을 우선하도록 우선순위를 두었고, 목적지 레지스터가 0인 경우는 x0 불변성을 위해 포워딩 대상에서 제외하였다. ForwardingUnit의 출력은 forwardA forwardB이며, 0은 포워딩 없음, 1은 MEM 단계에서 포워딩, 2는 WB 단계에서 포워딩을 의미하도록 설계하였다.
CPU 본체에서는 ForwardingUnit 출력에 따라 EX 단계의 rs1 rs2 값이 선택되도록 두 개의 MUX를 배치하였다. rs1 경로는 forwardA에 의해 ID EX의 readdata1, EX MEM의 writeback 값, MEM WB의 writeback 값 중 하나를 선택하고, rs2 경로는 forwardB에 의해 ID EX의 readdata2, EX MEM의 writeback 값, MEM WB의 writeback 값 중 하나를 선택한다. 선택된 결과는 ALU 입력으로 전달되며, x 입력은 alusrc1 제어에 의해 레지스터 값 0 PC 중에서 선택되고, y 입력은 immediate 제어에 의해 레지스터 값과 즉시값 중에서 선택되도록 연결하였다. 이 구성으로 산술 명령 사이의 RAW 의존성을 스톨 없이 해결할 수 있다.
또한 분기 비교 및 저장 명령의 데이터 경로에도 포워딩을 반영하였다. 분기 판단은 EX 단계에서 rs1 rs2 값을 비교하여 수행되므로 BranchControl의 입력에는 포워딩이 적용된 값이 들어가도록 연결하였다. 저장 명령의 경우 실제 메모리 write data는 MEM 단계에서 사용되지만 값은 EX MEM 레지스터에 미리 저장되므로, EX MEM에 저장되는 writedata 역시 포워딩이 적용된 rs2 값을 사용하도록 하였다. 결과적으로 레지스터 파일에 아직 반영되지 않은 최신 연산 결과가 다음 명령의 ALU 입력, 분기 비교 입력, store 데이터로 즉시 전달되어, 2번 문항의 멀티사이클 테스트에서 요구하는 데이터 의존성을 올바르게 처리할 수 있다.

# 3. Branching and flushing

3번 문항에서는 분기 및 점프 명령으로 인해 잘못 가져온 명령어들을 제거하고, 올바른 다음 PC로 제어 흐름을 복구하기 위해 branching과 flushing을 구현하였다. 본 과제는 always not-taken 예측을 가정하므로, IF 단계에서는 항상 PC+4로 다음 명령을 fetch하고, 실제로 분기/점프가 taken으로 판정되는 순간에만 파이프라인에 들어온 오경로(in-flight) 명령들을 flush/bubble 처리하여 무효화해야 한다. 구현의 핵심은 (1) taken이 발생했을 때 PC를 nextpc로 갱신하는 경로를 만들고, (2) 그 사이클에 존재하는 잘못된 명령들을 IF/ID flush 및 ID/EX, EX/MEM bubble inject로 제거하는 제어 신호를 생성하는 데 있다.
먼저 분기/점프의 taken 여부와 nextpc는 EX 단계의 조합 논리에서 계산되도록 구성하였다. EX 단계에서 BranchControl의 비교 결과와 jump 계열 제어 신호를 바탕으로 taken을 생성하고, 동시에 nextpc는 분기 타겟 주소 또는 점프 타겟 주소가 되도록 계산하였다. 이렇게 계산된 taken과 nextpc는 다음 단계에서도 사용할 수 있도록 EX/MEM 파이프라인 레지스터에 저장하였다. 이는 always not-taken 구조에서 “실제 taken 판정이 내려지는 시점”이 EX에서 계산되더라도, PC 갱신 및 flush 신호는 다음 단계 경계에서 안정적으로 제어되도록 하기 위한 설계이며, 결과적으로 MEM 단계에서 ex_mem.taken 및 ex_mem.nextpc를 기반으로 PC 갱신 및 파이프라인 정리를 수행한다.
PC 갱신은 fetch 단계의 PC 레지스터 입력에 MUX를 두어 구현하였다. 정상 동작에서는 PC+4를 선택하고, ex_mem.taken이 1인 경우에는 분기/점프 타겟 주소인 next_pc를 선택하도록 하였다. 이 선택은 hazard unit이 내보내는 pcwrite 신호로 제어되며, pcwrite가 “taken에 의한 갱신”을 의미할 때 next_pc를 선택하도록 연결하였다. 즉, always not-taken으로 인해 이미 IF에서 잘못된 경로의 명령을 가져오더라도, taken이 확인되는 시점에 PC가 즉시 올바른 타겟으로 전환되어 다음 사이클부터는 정상 경로의 fetch가 이루어진다.
오경로 명령 제거는 flush와 bubble inject를 결합해 처리하였다. 우선 IF/ID 레지스터는 taken이 발생한 사이클에 flush되도록 하여, 직전에 fetch되어 ID 단계로 들어오려던 잘못된 instruction을 NOP에 해당하는 값(또는 0)으로 덮어쓰게 하였다. 다음으로 ID/EX 레지스터에는 bubble inject를 적용하여, 이미 디코드되어 실행 단계로 진입하려던 오경로 명령이 EX 단계에서 유효한 제어 신호를 발생시키지 않도록 모든 제어 신호 및 데이터 경로를 무효화하였다. 또한 EX/MEM 레지스터에도 bubble inject를 적용하여, taken 판정 직후 단계에 존재하던 오경로 명령이 MEM 단계에서 메모리 접근이나 레지스터 writeback을 수행하지 못하도록 차단하였다. 결과적으로 taken이 발생하면 파이프라인 상에 남아 있던 잘못된 명령들이 순차적으로 NOP로 치환되며, 부작용(메모리 write, 레지스터 write)이 발생하지 않도록 보장된다.
위 flush/bubble 동작을 내는 제어 신호는 hazard unit에서 생성하였다. CPU는 ex_mem.taken을 hazard unit의 입력으로 연결하고, hazard unit은 taken이 1일 때 pcwrite를 “nextpc 선택” 값으로 설정하는 동시에 ifid_flush, idex_bubble, exmem_bubble을 모두 활성화하도록 하였다. 즉, branching에 의해 제어 흐름이 바뀌는 경우를 하나의 이벤트로 보고, 같은 사이클에 PC 갱신과 파이프라인 정리 신호를 함께 내보내도록 구현하여 타이밍을 단순화하였다. 이 구조는 always not-taken의 전형적인 flush 방식으로, taken 시점에 최소한의 제어 신호만으로 오경로 명령을 제거하고 정상 경로로 복귀할 수 있게 한다.
마지막으로 jump 및 branch 모두 동일한 메커니즘으로 처리되도록 통일하였다. EX 단계에서 taken과 nextpc가 어떤 종류의 제어 흐름 변경(branch/jal/jalr)에 의해 발생했는지와 무관하게, 최종적으로 ex_mem.taken이 1이면 동일하게 PC를 nextpc로 바꾸고 파이프라인을 flush/bubble 처리한다. 이를 통해 BranchTesterLab4 및 JumpTesterLab4에서 요구하는 분기 및 점프 동작이, always not-taken 가정 하에서도 올바르게 수행되도록 구현하였다.
