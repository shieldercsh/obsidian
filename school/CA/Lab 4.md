# 1. Adding pipelining registers

이번 과제의 1번 문항은 단일 사이클 CPU를 5단계 파이프라인 구조로 재구성하기 위해 단계 사이에 파이프라인 레지스터를 추가하고, 단계별 조합 논리 경로를 분리하여 연결하는 작업이다. 과제 요구에 따라 IF 단계 구현은 주어진 구조를 유지하고, ID EX MEM WB 단계를 완성하는 방향으로 구현을 진행하였다. 파이프라인 레지스터와 제어 신호는 Bundle로 정의하여 각 단계 경계에서 레지스터에 래치되도록 구성하였고, 스켈레톤에 남아 있던 DontCare는 실제 연결이 끝난 이후 의미 있는 값으로 구동되도록 제거하였다.
구현의 핵심은 데이터 경로와 제어 경로를 함께 파이프라인 레지스터에 실어 나르는 구조를 만드는 일이다. IF ID 레지스터에는 fetch된 instruction과 PC, PC+4를 저장하여 다음 사이클의 ID 단계가 안정적으로 디코드할 수 있게 하였다. ID 단계에서는 opcode를 기반으로 Control Unit이 생성한 제어 신호를 단계별로 분리하여 EXControl MControl WBControl로 묶고 이를 ID EX 레지스터에 저장하였다. 또한 레지스터 파일에서 읽어온 readdata1 readdata2, 목적지 레지스터 rd, 즉시값 imm, 그리고 분기 및 메모리 접근에 필요한 funct3 funct7도 ID EX로 전달하였다. 이 구성은 상승 에지에서 각 단계의 입력 상태를 고정하고 다음 사이클에 레지스터 출력만으로 다음 단계 조합 논리가 계산되는 전형적인 파이프라인 동작을 보장한다.
EX 단계에서는 ID EX에 저장된 제어 신호와 피연산자를 바탕으로 ALUControl을 통해 연산 종류를 결정하고, ALU 입력 선택을 위한 MUX를 구성하여 alusrc1 및 immediate 제어에 따라 입력을 선택하도록 하였다. 예를 들어 x 입력은 rs1 0 PC 중에서 선택되고 y 입력은 rs2 imm 중에서 선택된다. 계산된 ALU 결과와 store를 위한 writedata, 그리고 이후 단계에서 필요한 memread memwrite toreg regwrite 신호는 EX MEM 레지스터에 저장하여 MEM 단계에서 데이터 메모리 인터페이스에 직접 연결하였다. MEM 단계에서 얻은 readdata와 ALU 결과, PC+4, rd 및 WB 제어 신호는 MEM WB 레지스터에 저장하고, WB 단계에서는 toreg 값에 따라 ALU 결과 메모리 읽기 값 PC+4 중 하나를 선택해 레지스터 파일에 write back을 수행하도록 구성하였다. 또한 x0 레지스터 불변성을 보장하기 위해 rd가 0인 경우에는 write enable이 발생하지 않도록 조건을 추가하여 안정적인 동작을 확보하였다.

# 2. Forwarding logic

2번 문항에서는 데이터 해저드로 인해 EX 단계에서 필요한 피연산자가 아직 레지스터 파일에 기록되지 않은 상황을 해결하기 위해 포워딩 로직을 구현하였다. 포워딩의 목적은 파이프라인을 불필요하게 멈추지 않고도 최근에 계산된 결과를 바로 사용하게 하는 데 있으며, 이를 위해 MEM 단계와 WB 단계의 결과를 EX 단계로 우회 전달하는 경로를 추가하였다. 구현은 ForwardingUnit을 통해 의존 관계를 판별하고, 그 결과에 따라 EX 단계의 입력 선택 MUX가 적절한 값을 선택하도록 구성하였다.
ForwardingUnit은 EX 단계에서 사용되는 소스 레지스터 번호 rs1 rs2와, MEM 단계 및 WB 단계에 존재하는 명령의 목적지 레지스터 번호 exmemrd memwbrd 및 레지스터 파일 쓰기 여부 exmemrw memwbrw를 입력으로 받는다. 이후 rs1 rs2가 각각 exmemrd 또는 memwbrd와 일치하면서 해당 단계의 명령이 레지스터 파일에 값을 쓸 예정이면 포워딩이 필요하다고 판단한다. 이때 동일한 레지스터에 대해 MEM 단계와 WB 단계 모두가 후보가 될 수 있으므로, 가장 최신 값이 존재하는 MEM 단계 포워딩을 우선하도록 우선순위를 두었고, 목적지 레지스터가 0인 경우는 x0 불변성을 위해 포워딩 대상에서 제외하였다. ForwardingUnit의 출력은 forwardA forwardB이며, 0은 포워딩 없음, 1은 MEM 단계에서 포워딩, 2는 WB 단계에서 포워딩을 의미하도록 설계하였다.
CPU 본체에서는 ForwardingUnit 출력에 따라 EX 단계의 rs1 rs2 값이 선택되도록 두 개의 MUX를 배치하였다. rs1 경로는 forwardA에 의해 ID EX의 readdata1, EX MEM의 writeback 값, MEM WB의 writeback 값 중 하나를 선택하고, rs2 경로는 forwardB에 의해 ID EX의 readdata2, EX MEM의 writeback 값, MEM WB의 writeback 값 중 하나를 선택한다. 선택된 결과는 ALU 입력으로 전달되며, x 입력은 alusrc1 제어에 의해 레지스터 값 0 PC 중에서 선택되고, y 입력은 immediate 제어에 의해 레지스터 값과 즉시값 중에서 선택되도록 연결하였다. 이 구성으로 산술 명령 사이의 RAW 의존성을 스톨 없이 해결할 수 있다.
또한 분기 비교 및 저장 명령의 데이터 경로에도 포워딩을 반영하였다. 분기 판단은 EX 단계에서 rs1 rs2 값을 비교하여 수행되므로 BranchControl의 입력에는 포워딩이 적용된 값이 들어가도록 연결하였다. 저장 명령의 경우 실제 메모리 write data는 MEM 단계에서 사용되지만 값은 EX MEM 레지스터에 미리 저장되므로, EX MEM에 저장되는 writedata 역시 포워딩이 적용된 rs2 값을 사용하도록 하였다. 결과적으로 레지스터 파일에 아직 반영되지 않은 최신 연산 결과가 다음 명령의 ALU 입력, 분기 비교 입력, store 데이터로 즉시 전달되어, 2번 문항의 멀티사이클 테스트에서 요구하는 데이터 의존성을 올바르게 처리할 수 있다.

