# 1. Adding pipelining registers

이번 과제의 1번 문항은 단일 사이클 CPU를 5단계 파이프라인 구조로 재구성하기 위해 단계 사이에 파이프라인 레지스터를 추가하고, 단계별 조합 논리 경로를 분리하여 연결하는 작업이다. 과제 요구에 따라 IF 단계 구현은 주어진 구조를 유지하고, ID EX MEM WB 단계를 완성하는 방향으로 구현을 진행하였다. 파이프라인 레지스터와 제어 신호는 Bundle로 정의하여 각 단계 경계에서 레지스터에 래치되도록 구성하였고, 스켈레톤에 남아 있던 DontCare는 실제 연결이 끝난 이후 의미 있는 값으로 구동되도록 제거하였다.
구현의 핵심은 데이터 경로와 제어 경로를 함께 파이프라인 레지스터에 실어 나르는 구조를 만드는 일이다. IF ID 레지스터에는 fetch된 instruction과 PC, PC+4를 저장하여 다음 사이클의 ID 단계가 안정적으로 디코드할 수 있게 하였다. ID 단계에서는 opcode를 기반으로 Control Unit이 생성한 제어 신호를 단계별로 분리하여 EXControl MControl WBControl로 묶고 이를 ID EX 레지스터에 저장하였다. 또한 레지스터 파일에서 읽어온 readdata1 readdata2, 목적지 레지스터 rd, 즉시값 imm, 그리고 분기 및 메모리 접근에 필요한 funct3 funct7도 ID EX로 전달하였다. 이 구성은 상승 에지에서 각 단계의 입력 상태를 고정하고 다음 사이클에 레지스터 출력만으로 다음 단계 조합 논리가 계산되는 전형적인 파이프라인 동작을 보장한다.
EX 단계에서는 ID EX에 저장된 제어 신호와 피연산자를 바탕으로 ALUControl을 통해 연산 종류를 결정하고, ALU 입력 선택을 위한 MUX를 구성하여 alusrc1 및 immediate 제어에 따라 입력을 선택하도록 하였다. 예를 들어 x 입력은 rs1 0 PC 중에서 선택되고 y 입력은 rs2 imm 중에서 선택된다. 계산된 ALU 결과와 store를 위한 writedata, 그리고 이후 단계에서 필요한 memread memwrite toreg regwrite 신호는 EX MEM 레지스터에 저장하여 MEM 단계에서 데이터 메모리 인터페이스에 직접 연결하였다. MEM 단계에서 얻은 readdata와 ALU 결과, PC+4, rd 및 WB 제어 신호는 MEM WB 레지스터에 저장하고, WB 단계에서는 toreg 값에 따라 ALU 결과 메모리 읽기 값 PC+4 중 하나를 선택해 레지스터 파일에 write back을 수행하도록 구성하였다. 또한 x0 레지스터 불변성을 보장하기 위해 rd가 0인 경우에는 write enable이 발생하지 않도록 조건을 추가하여 안정적인 동작을 확보하였다.