`scanf`에 `+`나 `-`를 입력하면 아무것도 입력하지 않을 수 있다는 트릭이 있다. 값을 가져오는 곳에 코드 영역 주소가 있기 때문에 `+`를 입력하고 스택의 값을 더하면 `코드 영역 값 + alpha`의 값을 알 수 있고, 그냥 -1을 입력하면 `alpha`의 값을 알 수 있기 때문에 이 둘을 빼주고 `offset`을 빼주면 `pie_base`를 구할 수 있다.

```
0x7fffffffc850: 0x0000000000000000      0x0000000000000000
0x7fffffffc860: 0x0000000000000000      0x0000000000000000
0x7fffffffc870: 0x0000000000000000      0x0000000000000000
0x7fffffffc880: 0x0000000000000000      0x0000000000000000
0x7fffffffc890: 0x00007fffffffc9d8      0xd73910ae66126e00
0x7fffffffc8a0: 0x00007fffffffc8b0      0x000055555555558e
0x7fffffffc8b0: 0x00007fffffffc950      0x00007ffff7dc91ca
0x7fffffffc8c0: 0x00007fffffffc900      0x00007fffffffc9d8
```

`0x7fffffffc850`에 `unsigned long long int k[16];`이 선언되어 있다고 가정하자. `k[0] ~ k[7]`은 0으로 초기화되고, `k[8], k[10], k[12], k[14], k[15]`은 스택 관련 주소, `k[9]`는 카나리, `k[11]`은 코드 영역 주소, `k[13]`은 `libc` 관련 주소이다.
`base`를 `(1 << 56)`으로 설정하고 결과 값의 하위 6바이트만 보면 `k[15]`가 도출될 것이므로 스택 관련 주소의 모든 값을 알 수 있다. 이제 우리는 `k[9], k[13]`을 모르고 나머지 값은 다 안다.
다음으로 `k[13]`을 알아낼 것이다. 그렇게 생각한 이유는 `libc` 관련 주소는 상위 2바이트가 `\x00\x00`이기 때문이다. `base`를 `(1 << 63) + (1 << 8)`로 설정하고 최상위 바이트를 무시한다고 가정하면 `val`은 `((k[0] << 120) + ... + (k[8] << 56) + (k[9] << 48) + ... + (k[14] << 8) + k[15]) & ((1 << 64) - 1)`가 될 것이며, 이는 2바이트씩 밀려서 더해지는 형태가 될 것이다.
![[KakaoTalk_20250228_173012514.jpg]]

위 그림처럼 생각하면 `k[13]`의 하위 5바이트를 알 수 있다. `libc`는 `\x7e` 또는 `\x7f`로 시작하므로 합리적인 고정(`\x7f`)를 통해 `k[13]`을 알아낼 수 있다.